[["dimension-reduction-and-clustering.html", "Chapter 5 Dimension reduction and clustering 5.1 Identify top variable features 5.2 Dimension reduction 5.3 Clustering and joint clustering", " Chapter 5 Dimension reduction and clustering 5.1 Identify top variable features # Finding highly variable genes (feature selection), we return 2000 features per dataset by default pbmc &lt;- FindVariableFeatures(object = pbmc, selection.method =&quot;vst&quot;, mean.cutoff = c(0.1,6), dispersion.cutoff = c(0.5,Inf),verbose=TRUE) length(VariableFeatures(pbmc)) # [1] 2000 # return top 2000 variable features by default ## [1] &quot;GNLY&quot; &quot;IGKC&quot; &quot;IGHM&quot; &quot;PTGDS&quot; &quot;BANK1&quot; &quot;TCF4&quot; &quot;IGLC3&quot; &quot;JCHAIN&quot; ## [9] &quot;IGLC2&quot; &quot;CCL5&quot; ## When using repel, set xnudge and ynudge to 0 for optimal results Figure 5.1: Label the top 10 variable features 5.2 Dimension reduction Run separately for RNA and ATAC. min.dist and spread controls how tightly the points are clustered. # RNA analysis DefaultAssay(pbmc) &lt;- &quot;RNA&quot; pbmc &lt;- RunPCA(pbmc) DimPlot(object = pbmc) # determin if cell cycle has major variation # Running a PCA on cell cycle genes reveals DimPlot(pbmc,reduction = &quot;pca&quot;,group.by= &quot;Phase&quot;,split.by = &quot;Phase&quot;) Other visualization figures for determining dimensionality: # visualize the top genes associated with reduction components for the first 2 PCs VizDimLoadings(object = pbmc, dims = 1:2) Figure 5.2: Variations in top genes for the first two PCs # use heatmap DimHeatmap(object = pbmc, dims = 1:9, cells = 500, balanced = TRUE) Figure 5.3: Heatmap for visualizing heterogeneity in PCs ElbowPlot(object = pbmc) Figure 5.4: Checking elbow plot is the most common way for determining dimensionality We will do dimension reduction for scATAC-seq as well. # ATAC analysis DefaultAssay(pbmc) &lt;- &quot;ATAC&quot; pbmc &lt;- RunTFIDF(pbmc) pbmc &lt;- FindTopFeatures(pbmc, min.cutoff = &#39;q0&#39;) pbmc &lt;- RunSVD(pbmc) pbmc &lt;- RunUMAP(pbmc, reduction = &#39;lsi&#39;, dims = 2:50, reduction.name = &quot;umap.atac&quot;, reduction.key = &quot;atacUMAP_&quot;) 5.3 Clustering and joint clustering Clustering based on RNA assay. Play around with different resolutions. DefaultAssay(pbmc) &lt;- &quot;RNA&quot; pbmc &lt;- FindNeighbors(pbmc, dims = 1:50,force.recalc = T) pbmc &lt;- FindClusters(pbmc, algorithm = 3, resolution = 0.7, group.singletons=T) pbmc&lt;-RunUMAP(object = pbmc, dims = 1:50, reduction.name = &quot;umap.rna&quot;, reduction.key = &#39;rnaUMAP_&#39;, min.dist=0.3, spread=0.5,assay=&quot;SCT&quot;,slot=&quot;scale.data&quot;) DimPlot(pbmc, label = TRUE, repel = TRUE, reduction = &quot;umap.rna&quot;) Figure 5.5: Resolution=0.7 Generate a resolution tree for res=0.1 to 1.5 to select a suitable resolution. DefaultAssay(pbmc) &lt;- &quot;RNA&quot; resolutions &lt;- seq(0.1, 1.5, by = 0.1) # Initialize a list to store the clustering results clustering.list &lt;- list() # Loop over the resolution values and perform clustering for (i in 1:length(resolutions)){ # Run the FindClusters function with the resolution parameter pbmc &lt;- FindClusters(pbmc, algorithm = 3, resolution = resolutions[i], group.singletons=T, verbose = TRUE) # Store the cluster labels in the list clustering.list[[i]] &lt;- Idents(pbmc) print(i) } ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.9643 ## Number of communities: 8 ## Elapsed time: 7 seconds ## [1] 1 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.9444 ## Number of communities: 10 ## Elapsed time: 7 seconds ## [1] 2 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.9276 ## Number of communities: 13 ## Elapsed time: 6 seconds ## [1] 3 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.9140 ## Number of communities: 13 ## Elapsed time: 6 seconds ## [1] 4 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.9004 ## Number of communities: 14 ## Elapsed time: 6 seconds ## [1] 5 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8869 ## Number of communities: 14 ## Elapsed time: 5 seconds ## [1] 6 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8734 ## Number of communities: 15 ## Elapsed time: 5 seconds ## [1] 7 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8618 ## Number of communities: 17 ## Elapsed time: 5 seconds ## [1] 8 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8514 ## Number of communities: 17 ## Elapsed time: 6 seconds ## [1] 9 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8411 ## Number of communities: 17 ## Elapsed time: 5 seconds ## [1] 10 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8316 ## Number of communities: 18 ## Elapsed time: 5 seconds ## [1] 11 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8225 ## Number of communities: 19 ## Elapsed time: 5 seconds ## [1] 12 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8141 ## Number of communities: 20 ## Elapsed time: 5 seconds ## [1] 13 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.8064 ## Number of communities: 20 ## Elapsed time: 5 seconds ## [1] 14 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 10413 ## Number of edges: 497123 ## ## Running smart local moving algorithm... ## Maximum modularity in 10 random starts: 0.7984 ## Number of communities: 21 ## Elapsed time: 5 seconds ## [1] 15 names(clustering.list)&lt;-paste0(&quot;res_&quot;,resolutions) # Load the clustree package library(clustree) df&lt;- as.data.frame(lapply(clustering.list,as.factor)) # Plot the cluster tree for different resolution values clustree(df, prefix = &quot;res_&quot;) Figure 5.6: Clusters based on RNA assay vs joint assays # We exclude the first dimension for ATAC as this is typically correlated with sequencing depth pbmc &lt;- FindMultiModalNeighbors(pbmc, reduction.list = list(&quot;pca&quot;, &quot;lsi&quot;), dims.list = list(1:50, 2:50)) pbmc &lt;- RunUMAP(pbmc, nn.name = &quot;weighted.nn&quot;, reduction.name = &quot;wnn.umap&quot;, reduction.key = &quot;wnnUMAP_&quot;,min.dist=0.3, spread=0.5) pbmc &lt;- FindClusters(pbmc, graph.name = &quot;wsnn&quot;, algorithm = 3, resolution = 0.6, group.singletons=T,verbose = FALSE) You can further generate sub-clusters within large cluster to explore underlying structure pbmc &lt;- FindSubCluster(pbmc, cluster = 6, graph.name = &quot;wsnn&quot;, algorithm = 3) Idents(pbmc) &lt;- &quot;sub.cluster&quot; Compare: resolution=0.7 for RNA and resolution=0.6 for joint assays have similar number of clusters. p1 &lt;- DimPlot(pbmc, reduction = &quot;wnn.umap&quot;, group.by = &quot;RNA_snn_res.0.7&quot;, label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(&quot;RNA clusters&quot;) p2 &lt;- DimPlot(pbmc, reduction = &quot;wnn.umap&quot;, group.by = &quot;wsnn_res.0.6&quot;, label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(&quot;WNN clusters&quot;) p1 + p2 &amp; NoLegend() &amp; theme(plot.title = element_text(hjust = 0.5)) Figure 5.7: Clusters based on RNA assay vs joint assays compare: same cluster distribution on different assay space. p1 &lt;- DimPlot(pbmc, reduction = &quot;umap.rna&quot;, group.by = &quot;seurat_clusters&quot;, label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(&quot;RNA&quot;) p2 &lt;- DimPlot(pbmc, reduction = &quot;umap.atac&quot;, group.by = &quot;seurat_clusters&quot;, label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(&quot;ATAC&quot;) p3 &lt;- DimPlot(pbmc, reduction = &quot;wnn.umap&quot;, group.by = &quot;seurat_clusters&quot;, label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(&quot;WNN&quot;) p1 + p2 + p3 &amp; NoLegend() &amp; theme(plot.title = element_text(hjust = 0.5)) Figure 5.8: Clusters for single assay UMAP space vs joint assay space saveRDS(pbmc,file=&quot;pbmc_clust.rds&quot;) "],["cell-type-annotation.html", "Chapter 6 Cell type annotation", " Chapter 6 Cell type annotation We annotate the clusters below. Note that you could also annotate the dataset using supervised mapping pipelines or automated web tool, Azimuth. To annotate cell types in the dataset we can transfer cell labels from an existing PBMC reference dataset using tools in the Seurat package. See the Seurat reference mapping vignette for more information. We’ll use an annotated PBMC reference dataset from Hao et al. (2020), available for download here: https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat Note that the SeuratDisk package is required to load the reference dataset. Installation instructions for SeuratDisk can be found here. # download reference annotation wget https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat library(SeuratDisk) # load PBMC reference reference &lt;- LoadH5Seurat(&quot;../pbmc_data/pbmc_multimodal.h5seurat&quot;) DefaultAssay(pbmc) &lt;- &quot;SCT&quot; # transfer cell type labels from reference to query transfer_anchors &lt;- FindTransferAnchors( reference = reference, query = pbmc, reference.reduction=&quot;spca&quot;, normalization.method = &quot;SCT&quot;, dims = 1:50 ) # MapQuery() is a wrapper around three functions: TransferData(), IntegrateEmbeddings(), and ProjectUMAP() pbmc &lt;- MapQuery( anchorset = transfer_anchors, query = pbmc, reference = reference, refdata = list( celltype.l1 = &quot;celltype.l1&quot;, celltype.l2 = &quot;celltype.l2&quot;, predicted_ADT = &quot;ADT&quot; ), reference.reduction = &quot;spca&quot;, # reference has different types of reduction performed, pca, spca, umap ,etc. reduction.model = &quot;wnn.umap&quot;, transferdata.args=list(), integrateembeddings.args = list(), projectumap.args = list() ) saveRDS(pbmc,file=&quot;pbmc_anno.rds&quot;) # plot on reference data space p1&lt;-DimPlot(pbmc, reduction = &quot;ref.umap&quot;, group.by = &quot;predicted.celltype.l2&quot;, label = TRUE, label.size = 3 ,repel = TRUE) # plot on wnn space p2&lt;-DimPlot(pbmc, reduction = &quot;wnn.umap&quot;, group.by = &quot;predicted.celltype.l2&quot;, label = TRUE, label.size = 3 ,repel = TRUE) p1 + p2 &amp; NoLegend() &amp; theme(plot.title = element_text(hjust = 0.5)) Figure 6.1: Clusters for annotated cell types "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
